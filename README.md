# BST (Binary Search Tree)

* A binary search tree is a fundamental data structure useful for organizing
  large sets of data.
* A binary tree is built from nodes. Each node has:
  * An element of data
  * A link to the left. All nodes to the left have data elements less/lower
    than this node's data element.
  * A link to the right. All nodes to the right have data elements
    more/greater than this node's data element.

## Development Process

1. How will you know when the problem is solved?
* We will know when the problem is solved when we are able to run our code
  against some 'data' and it returns the values we expect. Some of the methods
  that we need to implement would be **insert**, **include?**, **depth_of**,
  **max**, **min**, **sort**, and **load** which in a text file and returns the
  number of unique values inserted into the tree.

2. How will it be used? It's interface? What do you put in and what do you get
out?
* It will be run in our file. It will have a main object that is the tree, which
  we can interact with using the above methods. You pass a string to the
  specific method you want to use. You get back the proper return value from the
  method.

3. What is the most trivial use case? (mvp-mvp)
* We can create an empty BinarySearchTreee and also create an empty Node

4. What's the minimum work case?
* We can create an empty BinarySearchTree and give it one Node.

5. What's the next most complex case?
* We can create an empty BinarySearchTree and give it two nodes.

5. What's the next most complex case?
*

5. What's the next most complex case?


6. Sketch an algorithm in pseudocode.
  1. Create an empty BinarySearchTree
  2. Check if BinarySearchTree has a "head" equal to nil
  3. Create an empty Node
  4. Check if a Node has data that is nil when created
  5. Check if a Node has a link to the left that is nil when      created
  6. Check if a Node has a link to the right that is nil when created
  7.
  7.
  7.
  8.
  9.

7. Implement

8. Whole Problem solved?
  * No? Return to 5

9. Anticipate problems / edge cases

10. Refactor

### Remember that 8 to 5 can repeat n times
